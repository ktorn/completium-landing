(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{123:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return b})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return p})),n.d(t,"default",(function(){return m}));var a=n(3),o=n(7),i=(n(0),n(236)),c=n(237),r=n(249),l=n(250),b={id:"verification5",title:"Postcondition",sidebar_label:"Postcondition",slug:"/verification/postcondition",hide_title:!1},s={unversionedId:"verification/verification5",id:"verification/verification5",isDocsHomePage:!1,title:"Postcondition",description:"An entrypoint's postcondition says what the execution of the entrypoint changes in the contract storage when it does not fail.",source:"@site/docs/verification/verification5.md",slug:"/verification/postcondition",permalink:"/docs/verification/postcondition",editUrl:"https://github.com/edukera/completium-landing/tree/master/docs/verification/verification5.md",version:"current",sidebar_label:"Postcondition",sidebar:"verification",previous:{title:"Introduction",permalink:"/docs/verification/specification"},next:{title:"Failure",permalink:"/docs/verification/fail"}},p=[{value:"Basics",id:"basics",children:[]},{value:"No change",id:"no-change",children:[]},{value:"Branches",id:"branches",children:[]},{value:"Collections",id:"collections",children:[{value:"Identified object",id:"identified-object",children:[]},{value:"No change",id:"no-change-1",children:[]},{value:"Unknown ids",id:"unknown-ids",children:[]}]}],d={toc:p};function m(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"An entrypoint's postcondition says what the execution of the entrypoint changes in the contract storage when it does not fail."),Object(i.b)("p",null,"Say the contract storage is made of ",Object(i.b)("em",{parentName:"p"},"S")," items (int, string, map, list, ...) and that the contract code is made of ",Object(i.b)("em",{parentName:"p"},"E")," entrypoints. There is ",Object(i.b)("em",{parentName:"p"},"S")," postconditions to describe the effect of one entrpoint on the ",Object(i.b)("em",{parentName:"p"},"S")," storage items, which is a total number of postconditions of ",Object(i.b)("em",{parentName:"p"},"E")," * ",Object(i.b)("em",{parentName:"p"},"S")," for the entire contract."),Object(i.b)("h2",{id:"basics"},"Basics"),Object(i.b)("p",null,"Consider the basic contract with one storage item ",Object(i.b)("inlineCode",{parentName:"p"},"value")," and one entrypoint ",Object(i.b)("inlineCode",{parentName:"p"},"set"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),'archetype trivial\nvariable value : string = ""\nentry set(v : string) { value := v }\n')),Object(i.b)("p",null,"There needs only one postcondition to describe the effect of the entrypoint on the storage:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"specification entry set(v : string) {\n  postcondition p {\n    value = v\n  }\n}\n")),Object(i.b)("p",null,"If the entrypoint can only be called by the ",Object(i.b)("inlineCode",{parentName:"p"},"owner")," address, the postcondition becomes:"),Object(i.b)(r.a,{defaultValue:"specification",values:[{label:"Specification",value:"specification"},{label:"Entrypoint",value:"archetype"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"specification",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"caller = owner -> value = v\n"))),Object(i.b)(l.a,{value:"archetype",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype",metastring:"{2}","{2}":!0}),"entry set(v : string) {\n  called by owner\n  effect {\n    value := v\n  }\n}\n")))),Object(i.b)("p",null,"The form of the postcondition above is:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"<CONDITION> -> <CHANGE>\n")),Object(i.b)("p",null,"which reads ",Object(i.b)("em",{parentName:"p"},"If")," ",Object(i.b)("inlineCode",{parentName:"p"},"CONDITION")," holds, ",Object(i.b)("em",{parentName:"p"},"then")," ",Object(i.b)("inlineCode",{parentName:"p"},"CHANGE")," ",Object(i.b)("em",{parentName:"p"},"occurs"),", or ",Object(i.b)("inlineCode",{parentName:"p"},"CONDITION")," ",Object(i.b)("em",{parentName:"p"},"implies")," ",Object(i.b)("inlineCode",{parentName:"p"},"CHANGE"),"."),Object(i.b)("h2",{id:"no-change"},"No change"),Object(i.b)("p",null,"When an entrypoint does not change a storage item, it is stated with the following postcondition:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"})," <ITEM> = before.<ITEM>\n")),Object(i.b)("p",null,"The prefix keyword ",Object(i.b)("inlineCode",{parentName:"p"},"before")," is used to refer to the state of the storage item ",Object(i.b)("inlineCode",{parentName:"p"},"ITEM")," ",Object(i.b)("em",{parentName:"p"},"before")," entrypoint execution. The storage item without prefix refers to the storage item ",Object(i.b)("em",{parentName:"p"},"after")," entrypoint execution."),Object(i.b)("p",null,"For example, below is the postcondition for the entrypoint ",Object(i.b)("inlineCode",{parentName:"p"},"transfer")," of the ",Object(i.b)(c.a,{to:"/docs/templates/fa12",mdxType:"Link"},"FA 1.2")," fungible token contract regarding the ",Object(i.b)("inlineCode",{parentName:"p"},"ledger")," storage item. It states that this storage item does not change if the parameter address ",Object(i.b)("inlineCode",{parentName:"p"},"%from")," is equal to the parameter address ",Object(i.b)("inlineCode",{parentName:"p"},"%to"),":"),Object(i.b)(r.a,{defaultValue:"specification",values:[{label:"Specification",value:"specification"},{label:"Entrypoint",value:"archetype"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"specification",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"%from = %to -> ledger = before.ledger\n"))),Object(i.b)(l.a,{value:"archetype",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype",metastring:"{11,12}","{11,12}":!0}),'entry %transfer (%from : address, %to : address, value : nat) {\n  require {\n    r1 otherwise "NotEnoughBalance" : ledger[%from].tokens >= value;\n  }\n  effect {\n    if caller <> %from then (\n      var current = allowance[(%from, caller)].amount;\n      dofailif(current < value, ("NotEnoughAllowance", ((value, current))));\n      allowance.update((%from, caller), { amount -=  value });\n    );\n    ledger.update(%from, { tokens -= value });\n    ledger.addupdate(%to, { tokens += value });\n  }\n}\n')),Object(i.b)("p",null,"The postcondition is not trivial since the code explicitely states how it changes the ",Object(i.b)("inlineCode",{parentName:"p"},"ledger")," asset, as highlighted in the code above. However, if ",Object(i.b)("inlineCode",{parentName:"p"},"%from")," equals ",Object(i.b)("inlineCode",{parentName:"p"},"%to"),", then there is no final change in the ",Object(i.b)("inlineCode",{parentName:"p"},"ledger")," item since ",Object(i.b)("inlineCode",{parentName:"p"},"value")," is subtracted and then added back to the address entry."))),Object(i.b)("h2",{id:"branches"},"Branches"),Object(i.b)("p",null,"To be complete, the postcondition above must say what changes when ",Object(i.b)("inlineCode",{parentName:"p"},"%from")," is different from ",Object(i.b)("inlineCode",{parentName:"p"},"%to"),"."),Object(i.b)("p",null,"A general form of the postcondition is actually:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"<CONDITION1> -> <CHANGE1> and\n<CONDITION2> -> <CHANGE2> and\n...\n<CONDITIONn> -> <CHANGEn>\n")),Object(i.b)("p",null,"where conditions 1 to n are such that they cover all branches of execution. More formally, conditions are such that the following statement is true:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"<CONDITION1> or <CONDITION2> or ... <CONDITIONn>\n")),Object(i.b)("p",null,"The postcondition for the ",Object(i.b)("inlineCode",{parentName:"p"},"tranfer")," entrypoint regarding the ",Object(i.b)("inlineCode",{parentName:"p"},"ledger")," item is then:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"%from =  %to ->  ledger = before.ledger and\n%from <> %to ->  <CHANGE>\n")),Object(i.b)("p",null,"Note that it is equivalent either to declare one postcondition formed as the conjunction of n implication statements, or to declare n postconditions of the form of an implication:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"postcondition p {\n  <CONDITION1> -> <CHANGE1> and <CONDITION2> -> <CHANGE2>\n}\n")),Object(i.b)("p",null,"is equivalent to:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"postcondition p1 {\n  <CONDITION1> -> <CHANGE1>\n}\n\npostcondition p2 {\n  <CONDITION2> -> <CHANGE2>\n}\n")),Object(i.b)("p",null,"The later form is preferred since it attributes an id to each implication statement, making the output from the formal system in charge of proving them more explicit."),Object(i.b)("h2",{id:"collections"},"Collections"),Object(i.b)("p",null,"This section deals with collections of pairs of key and value. Archetype provides 3 types of collections: Michelson ",Object(i.b)("em",{parentName:"p"},"map")," and ",Object(i.b)("em",{parentName:"p"},"big_map"),", and ",Object(i.b)(c.a,{to:"/docs/contract/tuto/archetype-assets",mdxType:"Link"},"asset")," used in examples below."),Object(i.b)("p",null,"Conversly to code language, retrieving an asset with key ",Object(i.b)("inlineCode",{parentName:"p"},"k")," from an asset collection ",Object(i.b)("inlineCode",{parentName:"p"},"c")," does not fail and the non existence is managed with the keyword ",Object(i.b)("inlineCode",{parentName:"p"},"otherwise"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"let some a = c[k] in\n  <EXISTSk>   (* there is an asset with key 'k' *)\notherwise\n  <NOTEXISTk> (* there is no asset with key 'k' *)\n")),Object(i.b)("h3",{id:"identified-object"},"Identified object"),Object(i.b)("p",null,"When an object ",Object(i.b)("inlineCode",{parentName:"p"},"a")," with known id ",Object(i.b)("inlineCode",{parentName:"p"},"k"),"  in a collection ",Object(i.b)("inlineCode",{parentName:"p"},"c")," is changed, the postcondition has the following structure:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"let some a = c[k] in\n  let some ba = before.c[k] in\n      <CHANGE>\n  otherwise\n      <NOTEXISTkBEFORE>\notherwise\n  <NOTEXISTkAFTER>\n")),Object(i.b)("p",null,"where:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a")," is the object associated to ",Object(i.b)("inlineCode",{parentName:"li"},"k")," ",Object(i.b)("em",{parentName:"li"},"after")," entrypoint execution"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"ba")," is the object associated to ",Object(i.b)("inlineCode",{parentName:"li"},"k")," ",Object(i.b)("em",{parentName:"li"},"before")," execution"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"CHANGE")," is the change in object a statement"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"NOTEXISTkBEFORE")," is the statement when ",Object(i.b)("inlineCode",{parentName:"li"},"a")," does not exist ",Object(i.b)("em",{parentName:"li"},"before")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"NOTEXISTkAFTER")," is the statement when ",Object(i.b)("inlineCode",{parentName:"li"},"a")," does not exist ",Object(i.b)("em",{parentName:"li"},"after"))),Object(i.b)("p",null,"For example, below is the postcondition ",Object(i.b)("inlineCode",{parentName:"p"},"p3_approve")," for the entrypoint ",Object(i.b)("inlineCode",{parentName:"p"},"approve")," of the ",Object(i.b)(c.a,{to:"/docs/templates/fa12",mdxType:"Link"},"FA 1.2")," fungible token contract regarding the ",Object(i.b)("inlineCode",{parentName:"p"},"allowance")," asset with key ",Object(i.b)("inlineCode",{parentName:"p"},"(caller,spender)"),". It corresponds to the ",Object(i.b)("inlineCode",{parentName:"p"},"addupdate")," code instruction."),Object(i.b)(r.a,{defaultValue:"specification",values:[{label:"Specification",value:"specification"},{label:"Entrypoint",value:"archetype"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"specification",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"let some a = allowance[(caller,spender)] in\n  let some ba = before.allowance[(caller,spender)] in\n    (* object is updated when object exists before *)\n    a = { ba with amount = value }\n  otherwise\n    (* object is added when it does not exist before *)\n    a = { addr_owner = caller; addr_spender = spender; amount = value }\notherwise\n  false\n"))),Object(i.b)(l.a,{value:"archetype",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype",metastring:"{7}","{7}":!0}),'entry approve(spender : address, value : nat) {\n  var k = (caller, spender);\n  if allowance.contains(k) then (\n    var previous = allowance[k].amount;\n    dofailif(previous > 0 and value > 0, (("UnsafeAllowanceChange", previous)));\n  );\n  allowance.addupdate( k, { amount = value });\n}\n')))),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"false")," statement means there is a logical contradiction. In the case above, it is not possible that the object with key ",Object(i.b)("inlineCode",{parentName:"p"},"(caller,spender)")," does not exist, as it is the semantic of the ",Object(i.b)("inlineCode",{parentName:"p"},"addupdate")," instruction (see code above in 'entrypoint' tab)."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"otherwise")," statements are presented below for instructions ",Object(i.b)("inlineCode",{parentName:"p"},"add"),", ",Object(i.b)("inlineCode",{parentName:"p"},"remove"),", ",Object(i.b)("inlineCode",{parentName:"p"},"update")," and ",Object(i.b)("inlineCode",{parentName:"p"},"addupdate"),":"),Object(i.b)(r.a,{defaultValue:"add",values:[{label:"Add",value:"add"},{label:"Remove",value:"remove"},{label:"Update",value:"update"},{label:"Addupdate",value:"addupdate"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"add",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"let some a = c[k] in\n  let some ba = before.c[k] in\n    false (* add fails if key already exists *)\n  otherwise\n    a = <ADDEDOBJECT>\notherwise\n  false (* object should exist after *)\n"))),Object(i.b)(l.a,{value:"remove",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"let some a = c[k] in\n  false (* object should not exist after *)\notherwise\n  let some ba = before.c[k] in\n    <REMOVED> (* say something about removed object *)\n  otherwise\n    false (* remove fails if key not found *)\n"))),Object(i.b)(l.a,{value:"update",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"let some a = c[k] in\n  let some ba = before.c[k] in\n    a = { ba with <CHANGES> }\n  otherwise\n    false (* update fails if key not found *)\notherwise\n  false (* update does not remove object *)\n"))),Object(i.b)(l.a,{value:"addupdate",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"let some a = c[k] in\n  let some ba = before.c[k] in\n    a = { ba with <CHANGES> }\n  otherwise\n    a = <ADDEDOBJECT>\notherwise\n  false (* update does not remove object *)\n")))),Object(i.b)("h3",{id:"no-change-1"},"No change"),Object(i.b)("p",null,"Postconditions say which objects are ",Object(i.b)("strong",{parentName:"p"},"not")," changed with a statement of the following form:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"forall a in c,\n  <NOTCHANGED> ->\n  let some ba = before.c[k] in\n    a = ba\n  otherwise\n    false\n")),Object(i.b)("p",null,"where ",Object(i.b)("inlineCode",{parentName:"p"},"CHANGED")," is the statement to say that object ",Object(i.b)("inlineCode",{parentName:"p"},"a")," is not a changed object."),Object(i.b)("p",null,"When object with key ",Object(i.b)("inlineCode",{parentName:"p"},"k")," is the only object changed, the postcondition is:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"forall a in c,\n  a.<KEY> <> k ->\n  let some ba = before.c[k] in\n    a = ba\n  otherwise\n    false\n")),Object(i.b)("p",null,"where ",Object(i.b)("inlineCode",{parentName:"p"},"KEY")," is the key field of the asset."),Object(i.b)("h3",{id:"unknown-ids"},"Unknown ids"),Object(i.b)("p",null,"When changed objects are not known by their ids, but rather by a business rule based on object data, the goal is to state the effect of the change on the collection."),Object(i.b)("p",null,"For example, below is the postcondition ",Object(i.b)("inlineCode",{parentName:"p"},"p2")," for the entrypoint ",Object(i.b)("inlineCode",{parentName:"p"},"consume")," of the ",Object(i.b)(c.a,{to:"/docs/templates/miles",mdxType:"Link"},"Miles")," contract. It states that the entrypoint reduces by parameter value ",Object(i.b)("inlineCode",{parentName:"p"},"quantity")," the total number of miles, which is the business intent of the entrypoint:"),Object(i.b)(r.a,{defaultValue:"specification",values:[{label:"Specification",value:"specification"},{label:"Entrypoint",value:"archetype"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"specification",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"})," mile.sum(the.amount) = before.mile.sum(the.amount) - quantity\n")),Object(i.b)("p",null,"The total number of miles is obtained by summing the field ",Object(i.b)("inlineCode",{parentName:"p"},"amount")," because miles are stored per bunch associated to an expiration date.")),Object(i.b)(l.a,{value:"archetype",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),'entry consume (ow : address, quantity : nat) {\n  called by admin\n  effect {\n    var lview = owner[ow].miles.sort(expiration).select(the.expiration >= now);\n    dorequire (lview.sum(the.amount) >= quantity, "NotEnoughMiles");\n    var remainder = quantity;\n    for : loop m in lview do\n      if remainder > 0 then begin\n        if mile[m].amount > remainder then begin\n          mile.update(m, { amount -= remainder });\n          remainder := 0\n        end else if mile[m].amount = remainder then begin\n          remainder := 0;\n          owner[ow].miles.remove(m)\n        end else begin\n          remainder -= mile[m].amount;\n          owner[ow].miles.remove(m)\n        end\n      end\n    done;\n    assert p1\n  }\n}\n')))),Object(i.b)("p",null,"Note that in this case, it is more complex to state exactly which miles are changed or not changed, as it is the result of an iteration process over a sorted and filtered set of miles."),Object(i.b)("p",null,"It is interesting though to make sure that only not expired miles are consumed (removed), since it is another key functional element of the contract:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"forall m in removed.mile, m.expiration > now\n")),Object(i.b)("p",null,"Note that Archetype specification language provides convenient handlers for removed or added assets. Another way to phrase this property is:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-archetype"}),"forall bm in before.mile,\n let some m = mile[bm.id] in\n  false (* no mile is added by the entrypoint *)\n otherwise\n  m.expiration > now\n")))}m.isMDXComponent=!0},242:function(e,t,n){"use strict";function a(e){var t,n,o="";if("string"==typeof e||"number"==typeof e)o+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(o&&(o+=" "),o+=n);else for(t in e)e[t]&&(o&&(o+=" "),o+=t);return o}t.a=function(){for(var e,t,n=0,o="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(o&&(o+=" "),o+=t);return o}},247:function(e,t,n){"use strict";var a=n(0),o=n(248);t.a=function(){const e=Object(a.useContext)(o.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},248:function(e,t,n){"use strict";var a=n(0);const o=Object(a.createContext)(void 0);t.a=o},249:function(e,t,n){"use strict";var a=n(0),o=n.n(a),i=n(247),c=n(242),r=n(56),l=n.n(r);const b=37,s=39;t.a=function(e){const{lazy:t,block:n,defaultValue:r,values:p,groupId:d,className:m}=e,{tabGroupChoices:u,setTabGroupChoices:h}=Object(i.a)(),[O,j]=Object(a.useState)(r),f=a.Children.toArray(e.children);if(null!=d){const e=u[d];null!=e&&e!==O&&p.some((t=>t.value===e))&&j(e)}const N=e=>{j(e),null!=d&&h(d,e)},g=[];return o.a.createElement("div",null,o.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(c.a)("tabs",{"tabs--block":n},m)},p.map((({value:e,label:t})=>o.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":O===e,className:Object(c.a)("tabs__item",l.a.tabItem,{"tabs__item--active":O===e}),key:e,ref:e=>g.push(e),onKeyDown:e=>{((e,t,n)=>{switch(n.keyCode){case s:((e,t)=>{const n=e.indexOf(t)+1;e[n]?e[n].focus():e[0].focus()})(e,t);break;case b:((e,t)=>{const n=e.indexOf(t)-1;e[n]?e[n].focus():e[e.length-1].focus()})(e,t)}})(g,e.target,e)},onFocus:()=>N(e),onClick:()=>{N(e)}},t)))),t?Object(a.cloneElement)(f.filter((e=>e.props.value===O))[0],{className:"margin-vert--md"}):o.a.createElement("div",{className:"margin-vert--md"},f.map(((e,t)=>Object(a.cloneElement)(e,{key:t,hidden:e.props.value!==O})))))}},250:function(e,t,n){"use strict";var a=n(3),o=n(0),i=n.n(o);t.a=function({children:e,hidden:t,className:n}){return i.a.createElement("div",Object(a.a)({role:"tabpanel"},{hidden:t,className:n}),e)}}}]);