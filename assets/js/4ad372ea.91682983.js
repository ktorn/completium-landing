"use strict";(self.webpackChunkcompletium_landing=self.webpackChunkcompletium_landing||[]).push([[9740],{8215:function(e,t,n){var a=n(7294);t.Z=function(e){var t=e.children,n=e.hidden,o=e.className;return a.createElement("div",{role:"tabpanel",hidden:n,className:o},t)}},6396:function(e,t,n){n.d(t,{Z:function(){return u}});var a=n(7462),o=n(7294),i=n(2389),r=n(9443);var l=function(){var e=(0,o.useContext)(r.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},s=n(1968),p=n(6010),c="tabItem_1uMI";function d(e){var t,n,a,i=e.lazy,r=e.block,d=e.defaultValue,u=e.values,m=e.groupId,h=e.className,k=o.Children.map(e.children,(function(e){if((0,o.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),f=null!=u?u:k.map((function(e){var t=e.props;return{value:t.value,label:t.label}})),N=(0,s.lx)(f,(function(e,t){return e.value===t.value}));if(N.length>0)throw new Error('Docusaurus error: Duplicate values "'+N.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var v=null===d?d:null!=(t=null!=d?d:null==(n=k.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(a=k[0])?void 0:a.props.value;if(null!==v&&!f.some((function(e){return e.value===v})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+f.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var b=l(),g=b.tabGroupChoices,y=b.setTabGroupChoices,w=(0,o.useState)(v),C=w[0],T=w[1],I=[],E=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=m){var x=g[m];null!=x&&x!==C&&f.some((function(e){return e.value===x}))&&T(x)}var O=function(e){var t=e.currentTarget,n=I.indexOf(t),a=f[n].value;a!==C&&(E(t),T(a),null!=m&&y(m,a))},A=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a=I.indexOf(e.currentTarget)+1;n=I[a]||I[0];break;case"ArrowLeft":var o=I.indexOf(e.currentTarget)-1;n=I[o]||I[I.length-1]}null==(t=n)||t.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,p.Z)("tabs",{"tabs--block":r},h)},f.map((function(e){var t=e.value,n=e.label;return o.createElement("li",{role:"tab",tabIndex:C===t?0:-1,"aria-selected":C===t,className:(0,p.Z)("tabs__item",c,{"tabs__item--active":C===t}),key:t,ref:function(e){return I.push(e)},onKeyDown:A,onFocus:O,onClick:O},null!=n?n:t)}))),i?(0,o.cloneElement)(k.filter((function(e){return e.props.value===C}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},k.map((function(e,t){return(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==C})}))))}function u(e){var t=(0,i.Z)();return o.createElement(d,(0,a.Z)({key:String(t)},e))}},4559:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return d},metadata:function(){return u},toc:function(){return m},default:function(){return k}});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),r=n(9960),l=n(6396),s=n(8215),p=["components"],c={id:"verification5",title:"Postcondition",sidebar_label:"Postcondition",slug:"/verification/postcondition",hide_title:!1},d=void 0,u={unversionedId:"verification/verification5",id:"verification/verification5",title:"Postcondition",description:"An entrypoint's postcondition says what the execution of the entrypoint changes in the contract storage when it does not fail.",source:"@site/docs/verification/verification5.md",sourceDirName:"verification",slug:"/verification/postcondition",permalink:"/docs/verification/postcondition",editUrl:"https://github.com/edukera/completium-landing/tree/master/docs/verification/verification5.md",tags:[],version:"current",frontMatter:{id:"verification5",title:"Postcondition",sidebar_label:"Postcondition",slug:"/verification/postcondition",hide_title:!1},sidebar:"verification",previous:{title:"Introduction",permalink:"/docs/verification/specification"},next:{title:"Failure",permalink:"/docs/verification/fail"}},m=[{value:"Basics",id:"basics",children:[],level:2},{value:"No change",id:"no-change",children:[],level:2},{value:"Branches",id:"branches",children:[],level:2},{value:"Collections",id:"collections",children:[{value:"Identified object",id:"identified-object",children:[],level:3},{value:"No change",id:"no-change-1",children:[],level:3},{value:"Unknown ids",id:"unknown-ids",children:[],level:3}],level:2}],h={toc:m};function k(e){var t=e.components,n=(0,o.Z)(e,p);return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An entrypoint's postcondition says what the execution of the entrypoint changes in the contract storage when it does not fail."),(0,i.kt)("p",null,"Say the contract storage is made of ",(0,i.kt)("em",{parentName:"p"},"S")," items (int, string, map, list, ...) and that the contract code is made of ",(0,i.kt)("em",{parentName:"p"},"E")," entrypoints. There is ",(0,i.kt)("em",{parentName:"p"},"S")," postconditions to describe the effect of one entrpoint on the ",(0,i.kt)("em",{parentName:"p"},"S")," storage items, which is a total number of postconditions of ",(0,i.kt)("em",{parentName:"p"},"E")," * ",(0,i.kt)("em",{parentName:"p"},"S")," for the entire contract."),(0,i.kt)("h2",{id:"basics"},"Basics"),(0,i.kt)("p",null,"Consider the basic contract with one storage item ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," and one entrypoint ",(0,i.kt)("inlineCode",{parentName:"p"},"set"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},'archetype trivial\nvariable value : string = ""\nentry set(v : string) { value := v }\n')),(0,i.kt)("p",null,"There needs only one postcondition to describe the effect of the entrypoint on the storage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"specification entry set(v : string) {\n  postcondition p {\n    value = v\n  }\n}\n")),(0,i.kt)("p",null,"If the entrypoint can only be called by the ",(0,i.kt)("inlineCode",{parentName:"p"},"owner")," address, the postcondition becomes:"),(0,i.kt)(l.Z,{defaultValue:"specification",values:[{label:"Specification",value:"specification"},{label:"Entrypoint",value:"archetype"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"specification",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"caller = owner -> value = v\n"))),(0,i.kt)(s.Z,{value:"archetype",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype",metastring:"{2}","{2}":!0},"entry set(v : string) {\n  called by owner\n  effect {\n    value := v\n  }\n}\n")))),(0,i.kt)("p",null,"The form of the postcondition above is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"<CONDITION> -> <CHANGE>\n")),(0,i.kt)("p",null,"which reads ",(0,i.kt)("em",{parentName:"p"},"If")," ",(0,i.kt)("inlineCode",{parentName:"p"},"CONDITION")," holds, ",(0,i.kt)("em",{parentName:"p"},"then")," ",(0,i.kt)("inlineCode",{parentName:"p"},"CHANGE")," ",(0,i.kt)("em",{parentName:"p"},"occurs"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"CONDITION")," ",(0,i.kt)("em",{parentName:"p"},"implies")," ",(0,i.kt)("inlineCode",{parentName:"p"},"CHANGE"),"."),(0,i.kt)("h2",{id:"no-change"},"No change"),(0,i.kt)("p",null,"When an entrypoint does not change a storage item, it is stated with the following postcondition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"}," <ITEM> = before.<ITEM>\n")),(0,i.kt)("p",null,"The prefix keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"before")," is used to refer to the state of the storage item ",(0,i.kt)("inlineCode",{parentName:"p"},"ITEM")," ",(0,i.kt)("em",{parentName:"p"},"before")," entrypoint execution. The storage item without prefix refers to the storage item ",(0,i.kt)("em",{parentName:"p"},"after")," entrypoint execution."),(0,i.kt)("p",null,"For example, below is the postcondition for the entrypoint ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer")," of the ",(0,i.kt)(r.Z,{to:"/docs/templates/fa12",mdxType:"Link"},"FA 1.2")," fungible token contract regarding the ",(0,i.kt)("inlineCode",{parentName:"p"},"ledger")," storage item. It states that this storage item does not change if the parameter address ",(0,i.kt)("inlineCode",{parentName:"p"},"%from")," is equal to the parameter address ",(0,i.kt)("inlineCode",{parentName:"p"},"%to"),":"),(0,i.kt)(l.Z,{defaultValue:"specification",values:[{label:"Specification",value:"specification"},{label:"Entrypoint",value:"archetype"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"specification",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"%from = %to -> ledger = before.ledger\n"))),(0,i.kt)(s.Z,{value:"archetype",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype",metastring:"{11,12}","{11,12}":!0},'entry %transfer (%from : address, %to : address, value : nat) {\n  require {\n    r1 otherwise "NotEnoughBalance" : ledger[%from].tokens >= value;\n  }\n  effect {\n    if caller <> %from then (\n      var current = allowance[(%from, caller)].amount;\n      dofailif(current < value, ("NotEnoughAllowance", ((value, current))));\n      allowance.update((%from, caller), { amount -=  value });\n    );\n    ledger.update(%from, { tokens -= value });\n    ledger.addupdate(%to, { tokens += value });\n  }\n}\n')),(0,i.kt)("p",null,"The postcondition is not trivial since the code explicitely states how it changes the ",(0,i.kt)("inlineCode",{parentName:"p"},"ledger")," asset, as highlighted in the code above. However, if ",(0,i.kt)("inlineCode",{parentName:"p"},"%from")," equals ",(0,i.kt)("inlineCode",{parentName:"p"},"%to"),", then there is no final change in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ledger")," item since ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," is subtracted and then added back to the address entry."))),(0,i.kt)("h2",{id:"branches"},"Branches"),(0,i.kt)("p",null,"To be complete, the postcondition above must say what changes when ",(0,i.kt)("inlineCode",{parentName:"p"},"%from")," is different from ",(0,i.kt)("inlineCode",{parentName:"p"},"%to"),"."),(0,i.kt)("p",null,"A general form of the postcondition is actually:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"<CONDITION1> -> <CHANGE1> and\n<CONDITION2> -> <CHANGE2> and\n...\n<CONDITIONn> -> <CHANGEn>\n")),(0,i.kt)("p",null,"where conditions 1 to n are such that they cover all branches of execution. More formally, conditions are such that the following statement is true:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"<CONDITION1> or <CONDITION2> or ... <CONDITIONn>\n")),(0,i.kt)("p",null,"The postcondition for the ",(0,i.kt)("inlineCode",{parentName:"p"},"tranfer")," entrypoint regarding the ",(0,i.kt)("inlineCode",{parentName:"p"},"ledger")," item is then:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"%from =  %to ->  ledger = before.ledger and\n%from <> %to ->  <CHANGE>\n")),(0,i.kt)("p",null,"Note that it is equivalent either to declare one postcondition formed as the conjunction of n implication statements, or to declare n postconditions of the form of an implication:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"postcondition p {\n  <CONDITION1> -> <CHANGE1> and <CONDITION2> -> <CHANGE2>\n}\n")),(0,i.kt)("p",null,"is equivalent to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"postcondition p1 {\n  <CONDITION1> -> <CHANGE1>\n}\n\npostcondition p2 {\n  <CONDITION2> -> <CHANGE2>\n}\n")),(0,i.kt)("p",null,"The later form is preferred since it attributes an id to each implication statement, making the output from the formal system in charge of proving them more explicit."),(0,i.kt)("h2",{id:"collections"},"Collections"),(0,i.kt)("p",null,"This section deals with collections of pairs of key and value. Archetype provides 3 types of collections: Michelson ",(0,i.kt)("em",{parentName:"p"},"map")," and ",(0,i.kt)("em",{parentName:"p"},"big_map"),", and ",(0,i.kt)(r.Z,{to:"/docs/contract/tuto/archetype-assets",mdxType:"Link"},"asset")," used in examples below."),(0,i.kt)("p",null,"Conversly to code language, retrieving an asset with key ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," from an asset collection ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," does not fail and the non existence is managed with the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"otherwise"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = c[k] in\n  <EXISTSk>   (* there is an asset with key 'k' *)\notherwise\n  <NOTEXISTk> (* there is no asset with key 'k' *)\n")),(0,i.kt)("h3",{id:"identified-object"},"Identified object"),(0,i.kt)("p",null,"When an object ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," with known id ",(0,i.kt)("inlineCode",{parentName:"p"},"k"),"  in a collection ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," is changed, the postcondition has the following structure:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = c[k] in\n  let some ba = before.c[k] in\n      <CHANGE>\n  otherwise\n      <NOTEXISTkBEFORE>\notherwise\n  <NOTEXISTkAFTER>\n")),(0,i.kt)("p",null,"where:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a")," is the object associated to ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," ",(0,i.kt)("em",{parentName:"li"},"after")," entrypoint execution"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ba")," is the object associated to ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," ",(0,i.kt)("em",{parentName:"li"},"before")," execution"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CHANGE")," is the change in object a statement"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"NOTEXISTkBEFORE")," is the statement when ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," does not exist ",(0,i.kt)("em",{parentName:"li"},"before")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"NOTEXISTkAFTER")," is the statement when ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," does not exist ",(0,i.kt)("em",{parentName:"li"},"after"))),(0,i.kt)("p",null,"For example, below is the postcondition ",(0,i.kt)("inlineCode",{parentName:"p"},"p3_approve")," for the entrypoint ",(0,i.kt)("inlineCode",{parentName:"p"},"approve")," of the ",(0,i.kt)(r.Z,{to:"/docs/templates/fa12",mdxType:"Link"},"FA 1.2")," fungible token contract regarding the ",(0,i.kt)("inlineCode",{parentName:"p"},"allowance")," asset with key ",(0,i.kt)("inlineCode",{parentName:"p"},"(caller,spender)"),". It corresponds to the ",(0,i.kt)("inlineCode",{parentName:"p"},"addupdate")," code instruction."),(0,i.kt)(l.Z,{defaultValue:"specification",values:[{label:"Specification",value:"specification"},{label:"Entrypoint",value:"archetype"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"specification",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = allowance[(caller,spender)] in\n  let some ba = before.allowance[(caller,spender)] in\n    (* object is updated when object exists before *)\n    a = { ba with amount = value }\n  otherwise\n    (* object is added when it does not exist before *)\n    a = { addr_owner = caller; addr_spender = spender; amount = value }\notherwise\n  false\n"))),(0,i.kt)(s.Z,{value:"archetype",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype",metastring:"{7}","{7}":!0},'entry approve(spender : address, value : nat) {\n  var k = (caller, spender);\n  if allowance.contains(k) then (\n    var previous = allowance[k].amount;\n    dofailif(previous > 0 and value > 0, (("UnsafeAllowanceChange", previous)));\n  );\n  allowance.addupdate( k, { amount = value });\n}\n')))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," statement means there is a logical contradiction. In the case above, it is not possible that the object with key ",(0,i.kt)("inlineCode",{parentName:"p"},"(caller,spender)")," does not exist, as it is the semantic of the ",(0,i.kt)("inlineCode",{parentName:"p"},"addupdate")," instruction (see code above in 'entrypoint' tab)."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"otherwise")," statements are presented below for instructions ",(0,i.kt)("inlineCode",{parentName:"p"},"add"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"remove"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"update")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"addupdate"),":"),(0,i.kt)(l.Z,{defaultValue:"add",values:[{label:"Add",value:"add"},{label:"Remove",value:"remove"},{label:"Update",value:"update"},{label:"Addupdate",value:"addupdate"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"add",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = c[k] in\n  let some ba = before.c[k] in\n    false (* add fails if key already exists *)\n  otherwise\n    a = <ADDEDOBJECT>\notherwise\n  false (* object should exist after *)\n"))),(0,i.kt)(s.Z,{value:"remove",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = c[k] in\n  false (* object should not exist after *)\notherwise\n  let some ba = before.c[k] in\n    <REMOVED> (* say something about removed object *)\n  otherwise\n    false (* remove fails if key not found *)\n"))),(0,i.kt)(s.Z,{value:"update",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = c[k] in\n  let some ba = before.c[k] in\n    a = { ba with <CHANGES> }\n  otherwise\n    false (* update fails if key not found *)\notherwise\n  false (* update does not remove object *)\n"))),(0,i.kt)(s.Z,{value:"addupdate",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = c[k] in\n  let some ba = before.c[k] in\n    a = { ba with <CHANGES> }\n  otherwise\n    a = <ADDEDOBJECT>\notherwise\n  false (* update does not remove object *)\n")))),(0,i.kt)("h3",{id:"no-change-1"},"No change"),(0,i.kt)("p",null,"Postconditions say which objects are ",(0,i.kt)("strong",{parentName:"p"},"not")," changed with a statement of the following form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"forall a in c,\n  <NOTCHANGED> ->\n  let some ba = before.c[k] in\n    a = ba\n  otherwise\n    false\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"CHANGED")," is the statement to say that object ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," is not a changed object."),(0,i.kt)("p",null,"When object with key ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," is the only object changed, the postcondition is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"forall a in c,\n  a.<KEY> <> k ->\n  let some ba = before.c[k] in\n    a = ba\n  otherwise\n    false\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"KEY")," is the key field of the asset."),(0,i.kt)("h3",{id:"unknown-ids"},"Unknown ids"),(0,i.kt)("p",null,"When changed objects are not known by their ids, but rather by a business rule based on object data, the goal is to state the effect of the change on the collection."),(0,i.kt)("p",null,"For example, below is the postcondition ",(0,i.kt)("inlineCode",{parentName:"p"},"p2")," for the entrypoint ",(0,i.kt)("inlineCode",{parentName:"p"},"consume")," of the ",(0,i.kt)(r.Z,{to:"/docs/templates/miles",mdxType:"Link"},"Miles")," contract. It states that the entrypoint reduces by parameter value ",(0,i.kt)("inlineCode",{parentName:"p"},"quantity")," the total number of miles, which is the business intent of the entrypoint:"),(0,i.kt)(l.Z,{defaultValue:"specification",values:[{label:"Specification",value:"specification"},{label:"Entrypoint",value:"archetype"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"specification",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"}," mile.sum(the.amount) = before.mile.sum(the.amount) - quantity\n")),(0,i.kt)("p",null,"The total number of miles is obtained by summing the field ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," because miles are stored per bunch associated to an expiration date.")),(0,i.kt)(s.Z,{value:"archetype",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},'entry consume (ow : address, quantity : nat) {\n  called by admin\n  effect {\n    var lview = owner[ow].miles.sort(expiration).select(the.expiration >= now);\n    dorequire (lview.sum(the.amount) >= quantity, "NotEnoughMiles");\n    var remainder = quantity;\n    for : loop m in lview do\n      if remainder > 0 then begin\n        if mile[m].amount > remainder then begin\n          mile.update(m, { amount -= remainder });\n          remainder := 0\n        end else if mile[m].amount = remainder then begin\n          remainder := 0;\n          owner[ow].miles.remove(m)\n        end else begin\n          remainder -= mile[m].amount;\n          owner[ow].miles.remove(m)\n        end\n      end\n    done;\n    assert p1\n  }\n}\n')))),(0,i.kt)("p",null,"Note that in this case, it is more complex to state exactly which miles are changed or not changed, as it is the result of an iteration process over a sorted and filtered set of miles."),(0,i.kt)("p",null,"It is interesting though to make sure that only not expired miles are consumed (removed), since it is another key functional element of the contract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"forall m in removed.mile, m.expiration > now\n")),(0,i.kt)("p",null,"Note that Archetype specification language provides convenient handlers for removed or added assets. Another way to phrase this property is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"forall bm in before.mile,\n let some m = mile[bm.id] in\n  false (* no mile is added by the entrypoint *)\n otherwise\n  m.expiration > now\n")))}k.isMDXComponent=!0}}]);