"use strict";(self.webpackChunkcompletium_landing=self.webpackChunkcompletium_landing||[]).push([[5236],{8215:function(e,t,n){var a=n(7294);t.Z=function(e){var t=e.children,n=e.hidden,i=e.className;return a.createElement("div",{role:"tabpanel",hidden:n,className:i},t)}},6396:function(e,t,n){n.d(t,{Z:function(){return d}});var a=n(7462),i=n(7294),o=n(2389),r=n(9443);var l=function(){var e=(0,i.useContext)(r.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},s=n(1968),c=n(6010),u="tabItem_1uMI";function p(e){var t,n,a,o=e.lazy,r=e.block,p=e.defaultValue,d=e.values,h=e.groupId,m=e.className,v=i.Children.map(e.children,(function(e){if((0,i.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),f=null!=d?d:v.map((function(e){var t=e.props;return{value:t.value,label:t.label}})),b=(0,s.lx)(f,(function(e,t){return e.value===t.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var k=null===p?p:null!=(t=null!=p?p:null==(n=v.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(a=v[0])?void 0:a.props.value;if(null!==k&&!f.some((function(e){return e.value===k})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+k+'" but none of its children has the corresponding value. Available values are: '+f.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var g=l(),y=g.tabGroupChoices,w=g.setTabGroupChoices,N=(0,i.useState)(k),x=N[0],I=N[1],T=[],C=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=h){var E=y[h];null!=E&&E!==x&&f.some((function(e){return e.value===E}))&&I(E)}var Z=function(e){var t=e.currentTarget,n=T.indexOf(t),a=f[n].value;a!==x&&(C(t),I(a),null!=h&&w(h,a))},_=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a=T.indexOf(e.currentTarget)+1;n=T[a]||T[0];break;case"ArrowLeft":var i=T.indexOf(e.currentTarget)-1;n=T[i]||T[T.length-1]}null==(t=n)||t.focus()};return i.createElement("div",{className:"tabs-container"},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":r},m)},f.map((function(e){var t=e.value,n=e.label;return i.createElement("li",{role:"tab",tabIndex:x===t?0:-1,"aria-selected":x===t,className:(0,c.Z)("tabs__item",u,{"tabs__item--active":x===t}),key:t,ref:function(e){return T.push(e)},onKeyDown:_,onFocus:Z,onClick:Z},null!=n?n:t)}))),o?(0,i.cloneElement)(v.filter((function(e){return e.props.value===x}))[0],{className:"margin-vert--md"}):i.createElement("div",{className:"margin-vert--md"},v.map((function(e,t){return(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==x})}))))}function d(e){var t=(0,o.Z)();return i.createElement(p,(0,a.Z)({key:String(t)},e))}},921:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return u},toc:function(){return p},default:function(){return h}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=n(9960),l=(n(6396),n(8215),["components"]),s={id:"verification7",title:"Invariant",sidebar_label:"Invariant",slug:"/verification/invariant",hide_title:!1},c=void 0,u={unversionedId:"verification/verification7",id:"verification/verification7",title:"Invariant",description:"An invariant is a property of the contract state (storage, balance) that is always true, regardless of the history of calls to the contract.",source:"@site/docs/verification/verification7.md",sourceDirName:"verification",slug:"/verification/invariant",permalink:"/docs/verification/invariant",editUrl:"https://github.com/edukera/completium-landing/tree/master/docs/verification/verification7.md",tags:[],version:"current",frontMatter:{id:"verification7",title:"Invariant",sidebar_label:"Invariant",slug:"/verification/invariant",hide_title:!1},sidebar:"verification",previous:{title:"Failure",permalink:"/docs/verification/fail"},next:{title:"Conclusion",permalink:"/docs/verification/conclusion"}},p=[{value:"Conservation",id:"conservation",children:[],level:2},{value:"Accumulation",id:"accumulation",children:[{value:"Example",id:"example",children:[],level:3},{value:"Shadow variables",id:"shadow-variables",children:[],level:3}],level:2}],d={toc:p};function h(e){var t=e.components,n=(0,i.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"An invariant is a property of the contract state (storage, balance) that is always true, regardless of the history of calls to the contract."),(0,o.kt)("p",null,"If there are ",(0,o.kt)("em",{parentName:"p"},"E")," entrypoints in the contract, ",(0,o.kt)(r.Z,{to:"http://why3.lri.fr/",mdxType:"Link"},"Why3")," will automatically generate ",(0,o.kt)("em",{parentName:"p"},"E+1")," proof obligations out of one invariant:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"one for the initial storage value: the invariant is true at the contract origination"),(0,o.kt)("li",{parentName:"ul"},"one per entrypoint to prove the invariant as a postcondition, assuming the property holds before entrypoint execution")),(0,o.kt)("p",null,'There is no systemic method to establish contract invariants. You need to figure them out case by case by aksing "what do entrypoints preserve?" or "which relations hold between storage variables?" Below is a presentation of two principles you can use to figure out invariants.'),(0,o.kt)("h2",{id:"conservation"},"Conservation"),(0,o.kt)("p",null,"In these examples, the invariant comes from the fact that information is transfered by entrypoints from one place to the other in the contract storage. It is then possible to write a global conservation equation."),(0,o.kt)("p",null,"The invariant of the ",(0,o.kt)(r.Z,{to:"/docs/templates/fa12",mdxType:"Link"},"FA 1.2")," contract states that the total number of tokens is a constant. Indeed tokens are transferred from one account to the other, but the total number of tokens is conserved, no token is minted or lost:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"specification {\n  i: ledger.sum(tokens) = totalsupply;\n}\n")),(0,o.kt)("p",null,"The invariant of the ",(0,o.kt)(r.Z,{to:"/docs/templates/ideabox",mdxType:"Link"},"Idea Box")," contract is a conservation equation between maximum number of votes per voter, the actual number of votes received by ideas, and the remaining number of votes per voter."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"specification {\n  i1 : maxvotes * voter.count() = idea.sum(nbvotes) + voter.sum(remaining)\n}\n")),(0,o.kt)("p",null,"Note that the invariant is global and that it is not possible in this case to state the conservation principle at the voter level, because the contract does not store the information of which voter voted for which idea."),(0,o.kt)("h2",{id:"accumulation"},"Accumulation"),(0,o.kt)("h3",{id:"example"},"Example"),(0,o.kt)("p",null,"In this example, the invariant comes from the fact that an information is the accumulation of other information as a result of calls to entrypoints. It is then possible to write an accumulation equation."),(0,o.kt)("p",null,"Say the contract is selling non fungible tokens, and each time a token is sold, the balance is increased by a percent of the token fixed price, the fee. Say the information is stored in an asset collection ",(0,o.kt)("inlineCode",{parentName:"p"},"ledger")," defined as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"variable fee : rational = 0.003\n\nasset ledger {\n  id        : string,\n  price     : tez,\n  sellcount : nat = 0\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"sellcount")," is the number of times the token has been sold."),(0,o.kt)("p",null,"The contract invariant is then the formula for the balance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"balance = fee * ledger.sum(sellcount * price)\n")),(0,o.kt)("h3",{id:"shadow-variables"},"Shadow variables"),(0,o.kt)("p",null,"If an information is missing to express the invariant, it is possible to use ",(0,o.kt)("em",{parentName:"p"},"shadow variables"),": they do not appear in the final contract storage or code, while they are available in specification."),(0,o.kt)("p",null,"Typically the ",(0,o.kt)("inlineCode",{parentName:"p"},"sellcount")," field in the above example is a pure accumulation variable only used the invariant formula. It is then better not to have it as a real field and pay for its storage, and turn it into a shadow field."),(0,o.kt)("p",null,"The following shows how to declare ",(0,o.kt)("inlineCode",{parentName:"p"},"sellcount")," as a shadow field:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"asset ledger {\n  id        : string,\n  price     : tez\n} shadow {\n  sellcount : int = 0;\n}\n")),(0,o.kt)("p",null,"Shadow variables cannot be used in entrypoints' effect. It can only be used in dedicated shadow effect sections. Shadow effects are virtually executed ",(0,o.kt)("em",{parentName:"p"},"after")," the entrypoint section."),(0,o.kt)("p",null,"In this case, the ",(0,o.kt)("inlineCode",{parentName:"p"},"sell")," entrypoint declares such a section to accumulate the number of times a card is sold:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"entry sell(i : string) {\n  specification {\n    shadow effect {\n      ledger[i].sellcount += 1\n    }\n  }\n  effect {\n    ...\n  }\n}\n")),(0,o.kt)("p",null,"With shadow variables it is possible to accumulate what is necessary to formulate the invariant. In the Box Idea contract presented above, it would be possible to add an field in the ",(0,o.kt)("inlineCode",{parentName:"p"},"voter")," asset that stores the sum of weights:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"asset voter {\n  addr        : address;\n  remaining   : nat = maxvotes;\n} shadow {\n  totalweight : nat = 0;\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"vote")," entrypoint would have a shadow effect to store the idea's id:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"entry vote(n : nat, weight : nat) {\n  specification {\n    shadow effect {\n      voter[caller].totalweight += weight\n    }\n  }\n  effect {\n    ...\n  }\n}\n")),(0,o.kt)("p",null,"The invariant may then use this shadow information to express maximum vote conservation at voter's level:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"forall v in voter,\n  v.maxvotes = v.totalweight + v.remaining\n")))}h.isMDXComponent=!0}}]);