(self.webpackChunkcompletium_landing=self.webpackChunkcompletium_landing||[]).push([[9740],{8215:function(e,t,n){"use strict";var a=n(7294);t.Z=function(e){var t=e.children,n=e.hidden,i=e.className;return a.createElement("div",{role:"tabpanel",hidden:n,className:i},t)}},5064:function(e,t,n){"use strict";n.d(t,{Z:function(){return d}});var a=n(7294),i=n(9443);var o=function(){var e=(0,a.useContext)(i.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},r=n(6010),l="tabItem_1uMI",s="tabItemActive_2DSg";var p=37,c=39;var d=function(e){var t=e.lazy,n=e.block,i=e.defaultValue,d=e.values,m=e.groupId,u=e.className,h=o(),k=h.tabGroupChoices,f=h.setTabGroupChoices,N=(0,a.useState)(i),g=N[0],b=N[1],v=a.Children.toArray(e.children),y=[];if(null!=m){var w=k[m];null!=w&&w!==g&&d.some((function(e){return e.value===w}))&&b(w)}var C=function(e){var t=e.currentTarget,n=y.indexOf(t),a=d[n].value;b(a),null!=m&&(f(m,a),setTimeout((function(){var e,n,a,i,o,r,l,p;(e=t.getBoundingClientRect(),n=e.top,a=e.left,i=e.bottom,o=e.right,r=window,l=r.innerHeight,p=r.innerWidth,n>=0&&o<=p&&i<=l&&a>=0)||(t.scrollIntoView({block:"center",behavior:"smooth"}),t.classList.add(s),setTimeout((function(){return t.classList.remove(s)}),2e3))}),150))},T=function(e){var t,n;switch(e.keyCode){case c:var a=y.indexOf(e.target)+1;n=y[a]||y[0];break;case p:var i=y.indexOf(e.target)-1;n=y[i]||y[y.length-1]}null==(t=n)||t.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},u)},d.map((function(e){var t=e.value,n=e.label;return a.createElement("li",{role:"tab",tabIndex:g===t?0:-1,"aria-selected":g===t,className:(0,r.Z)("tabs__item",l,{"tabs__item--active":g===t}),key:t,ref:function(e){return y.push(e)},onKeyDown:T,onFocus:C,onClick:C},n)}))),t?(0,a.cloneElement)(v.filter((function(e){return e.props.value===g}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},v.map((function(e,t){return(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==g})}))))}},9443:function(e,t,n){"use strict";var a=(0,n(7294).createContext)(void 0);t.Z=a},1656:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return d},metadata:function(){return m},toc:function(){return u},default:function(){return k}});var a=n(2122),i=n(9756),o=(n(7294),n(3905)),r=n(6742),l=n(5064),s=n(8215),p=["components"],c={id:"verification5",title:"Postcondition",sidebar_label:"Postcondition",slug:"/verification/postcondition",hide_title:!1},d=void 0,m={unversionedId:"verification/verification5",id:"verification/verification5",isDocsHomePage:!1,title:"Postcondition",description:"An entrypoint's postcondition says what the execution of the entrypoint changes in the contract storage when it does not fail.",source:"@site/docs/verification/verification5.md",sourceDirName:"verification",slug:"/verification/postcondition",permalink:"/docs/verification/postcondition",editUrl:"https://github.com/edukera/completium-landing/tree/master/docs/verification/verification5.md",version:"current",frontMatter:{id:"verification5",title:"Postcondition",sidebar_label:"Postcondition",slug:"/verification/postcondition",hide_title:!1},sidebar:"verification",previous:{title:"Introduction",permalink:"/docs/verification/specification"},next:{title:"Failure",permalink:"/docs/verification/fail"}},u=[{value:"Basics",id:"basics",children:[]},{value:"No change",id:"no-change",children:[]},{value:"Branches",id:"branches",children:[]},{value:"Collections",id:"collections",children:[{value:"Identified object",id:"identified-object",children:[]},{value:"No change",id:"no-change-1",children:[]},{value:"Unknown ids",id:"unknown-ids",children:[]}]}],h={toc:u};function k(e){var t=e.components,n=(0,i.Z)(e,p);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"An entrypoint's postcondition says what the execution of the entrypoint changes in the contract storage when it does not fail."),(0,o.kt)("p",null,"Say the contract storage is made of ",(0,o.kt)("em",{parentName:"p"},"S")," items (int, string, map, list, ...) and that the contract code is made of ",(0,o.kt)("em",{parentName:"p"},"E")," entrypoints. There is ",(0,o.kt)("em",{parentName:"p"},"S")," postconditions to describe the effect of one entrpoint on the ",(0,o.kt)("em",{parentName:"p"},"S")," storage items, which is a total number of postconditions of ",(0,o.kt)("em",{parentName:"p"},"E")," * ",(0,o.kt)("em",{parentName:"p"},"S")," for the entire contract."),(0,o.kt)("h2",{id:"basics"},"Basics"),(0,o.kt)("p",null,"Consider the basic contract with one storage item ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," and one entrypoint ",(0,o.kt)("inlineCode",{parentName:"p"},"set"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},'archetype trivial\nvariable value : string = ""\nentry set(v : string) { value := v }\n')),(0,o.kt)("p",null,"There needs only one postcondition to describe the effect of the entrypoint on the storage:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"specification entry set(v : string) {\n  postcondition p {\n    value = v\n  }\n}\n")),(0,o.kt)("p",null,"If the entrypoint can only be called by the ",(0,o.kt)("inlineCode",{parentName:"p"},"owner")," address, the postcondition becomes:"),(0,o.kt)(l.Z,{defaultValue:"specification",values:[{label:"Specification",value:"specification"},{label:"Entrypoint",value:"archetype"}],mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"specification",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"caller = owner -> value = v\n"))),(0,o.kt)(s.Z,{value:"archetype",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype",metastring:"{2}","{2}":!0},"entry set(v : string) {\n  called by owner\n  effect {\n    value := v\n  }\n}\n")))),(0,o.kt)("p",null,"The form of the postcondition above is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"<CONDITION> -> <CHANGE>\n")),(0,o.kt)("p",null,"which reads ",(0,o.kt)("em",{parentName:"p"},"If")," ",(0,o.kt)("inlineCode",{parentName:"p"},"CONDITION")," holds, ",(0,o.kt)("em",{parentName:"p"},"then")," ",(0,o.kt)("inlineCode",{parentName:"p"},"CHANGE")," ",(0,o.kt)("em",{parentName:"p"},"occurs"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"CONDITION")," ",(0,o.kt)("em",{parentName:"p"},"implies")," ",(0,o.kt)("inlineCode",{parentName:"p"},"CHANGE"),"."),(0,o.kt)("h2",{id:"no-change"},"No change"),(0,o.kt)("p",null,"When an entrypoint does not change a storage item, it is stated with the following postcondition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"}," <ITEM> = before.<ITEM>\n")),(0,o.kt)("p",null,"The prefix keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"before")," is used to refer to the state of the storage item ",(0,o.kt)("inlineCode",{parentName:"p"},"ITEM")," ",(0,o.kt)("em",{parentName:"p"},"before")," entrypoint execution. The storage item without prefix refers to the storage item ",(0,o.kt)("em",{parentName:"p"},"after")," entrypoint execution."),(0,o.kt)("p",null,"For example, below is the postcondition for the entrypoint ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer")," of the ",(0,o.kt)(r.Z,{to:"/docs/templates/fa12",mdxType:"Link"},"FA 1.2")," fungible token contract regarding the ",(0,o.kt)("inlineCode",{parentName:"p"},"ledger")," storage item. It states that this storage item does not change if the parameter address ",(0,o.kt)("inlineCode",{parentName:"p"},"%from")," is equal to the parameter address ",(0,o.kt)("inlineCode",{parentName:"p"},"%to"),":"),(0,o.kt)(l.Z,{defaultValue:"specification",values:[{label:"Specification",value:"specification"},{label:"Entrypoint",value:"archetype"}],mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"specification",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"%from = %to -> ledger = before.ledger\n"))),(0,o.kt)(s.Z,{value:"archetype",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype",metastring:"{11,12}","{11,12}":!0},'entry %transfer (%from : address, %to : address, value : nat) {\n  require {\n    r1 otherwise "NotEnoughBalance" : ledger[%from].tokens >= value;\n  }\n  effect {\n    if caller <> %from then (\n      var current = allowance[(%from, caller)].amount;\n      dofailif(current < value, ("NotEnoughAllowance", ((value, current))));\n      allowance.update((%from, caller), { amount -=  value });\n    );\n    ledger.update(%from, { tokens -= value });\n    ledger.addupdate(%to, { tokens += value });\n  }\n}\n')),(0,o.kt)("p",null,"The postcondition is not trivial since the code explicitely states how it changes the ",(0,o.kt)("inlineCode",{parentName:"p"},"ledger")," asset, as highlighted in the code above. However, if ",(0,o.kt)("inlineCode",{parentName:"p"},"%from")," equals ",(0,o.kt)("inlineCode",{parentName:"p"},"%to"),", then there is no final change in the ",(0,o.kt)("inlineCode",{parentName:"p"},"ledger")," item since ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," is subtracted and then added back to the address entry."))),(0,o.kt)("h2",{id:"branches"},"Branches"),(0,o.kt)("p",null,"To be complete, the postcondition above must say what changes when ",(0,o.kt)("inlineCode",{parentName:"p"},"%from")," is different from ",(0,o.kt)("inlineCode",{parentName:"p"},"%to"),"."),(0,o.kt)("p",null,"A general form of the postcondition is actually:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"<CONDITION1> -> <CHANGE1> and\n<CONDITION2> -> <CHANGE2> and\n...\n<CONDITIONn> -> <CHANGEn>\n")),(0,o.kt)("p",null,"where conditions 1 to n are such that they cover all branches of execution. More formally, conditions are such that the following statement is true:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"<CONDITION1> or <CONDITION2> or ... <CONDITIONn>\n")),(0,o.kt)("p",null,"The postcondition for the ",(0,o.kt)("inlineCode",{parentName:"p"},"tranfer")," entrypoint regarding the ",(0,o.kt)("inlineCode",{parentName:"p"},"ledger")," item is then:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"%from =  %to ->  ledger = before.ledger and\n%from <> %to ->  <CHANGE>\n")),(0,o.kt)("p",null,"Note that it is equivalent either to declare one postcondition formed as the conjunction of n implication statements, or to declare n postconditions of the form of an implication:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"postcondition p {\n  <CONDITION1> -> <CHANGE1> and <CONDITION2> -> <CHANGE2>\n}\n")),(0,o.kt)("p",null,"is equivalent to:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"postcondition p1 {\n  <CONDITION1> -> <CHANGE1>\n}\n\npostcondition p2 {\n  <CONDITION2> -> <CHANGE2>\n}\n")),(0,o.kt)("p",null,"The later form is preferred since it attributes an id to each implication statement, making the output from the formal system in charge of proving them more explicit."),(0,o.kt)("h2",{id:"collections"},"Collections"),(0,o.kt)("p",null,"This section deals with collections of pairs of key and value. Archetype provides 3 types of collections: Michelson ",(0,o.kt)("em",{parentName:"p"},"map")," and ",(0,o.kt)("em",{parentName:"p"},"big_map"),", and ",(0,o.kt)(r.Z,{to:"/docs/contract/tuto/archetype-assets",mdxType:"Link"},"asset")," used in examples below."),(0,o.kt)("p",null,"Conversly to code language, retrieving an asset with key ",(0,o.kt)("inlineCode",{parentName:"p"},"k")," from an asset collection ",(0,o.kt)("inlineCode",{parentName:"p"},"c")," does not fail and the non existence is managed with the keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"otherwise"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = c[k] in\n  <EXISTSk>   (* there is an asset with key 'k' *)\notherwise\n  <NOTEXISTk> (* there is no asset with key 'k' *)\n")),(0,o.kt)("h3",{id:"identified-object"},"Identified object"),(0,o.kt)("p",null,"When an object ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," with known id ",(0,o.kt)("inlineCode",{parentName:"p"},"k"),"  in a collection ",(0,o.kt)("inlineCode",{parentName:"p"},"c")," is changed, the postcondition has the following structure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = c[k] in\n  let some ba = before.c[k] in\n      <CHANGE>\n  otherwise\n      <NOTEXISTkBEFORE>\notherwise\n  <NOTEXISTkAFTER>\n")),(0,o.kt)("p",null,"where:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"a")," is the object associated to ",(0,o.kt)("inlineCode",{parentName:"li"},"k")," ",(0,o.kt)("em",{parentName:"li"},"after")," entrypoint execution"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ba")," is the object associated to ",(0,o.kt)("inlineCode",{parentName:"li"},"k")," ",(0,o.kt)("em",{parentName:"li"},"before")," execution"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"CHANGE")," is the change in object a statement"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"NOTEXISTkBEFORE")," is the statement when ",(0,o.kt)("inlineCode",{parentName:"li"},"a")," does not exist ",(0,o.kt)("em",{parentName:"li"},"before")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"NOTEXISTkAFTER")," is the statement when ",(0,o.kt)("inlineCode",{parentName:"li"},"a")," does not exist ",(0,o.kt)("em",{parentName:"li"},"after"))),(0,o.kt)("p",null,"For example, below is the postcondition ",(0,o.kt)("inlineCode",{parentName:"p"},"p3_approve")," for the entrypoint ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," of the ",(0,o.kt)(r.Z,{to:"/docs/templates/fa12",mdxType:"Link"},"FA 1.2")," fungible token contract regarding the ",(0,o.kt)("inlineCode",{parentName:"p"},"allowance")," asset with key ",(0,o.kt)("inlineCode",{parentName:"p"},"(caller,spender)"),". It corresponds to the ",(0,o.kt)("inlineCode",{parentName:"p"},"addupdate")," code instruction."),(0,o.kt)(l.Z,{defaultValue:"specification",values:[{label:"Specification",value:"specification"},{label:"Entrypoint",value:"archetype"}],mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"specification",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = allowance[(caller,spender)] in\n  let some ba = before.allowance[(caller,spender)] in\n    (* object is updated when object exists before *)\n    a = { ba with amount = value }\n  otherwise\n    (* object is added when it does not exist before *)\n    a = { addr_owner = caller; addr_spender = spender; amount = value }\notherwise\n  false\n"))),(0,o.kt)(s.Z,{value:"archetype",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype",metastring:"{7}","{7}":!0},'entry approve(spender : address, value : nat) {\n  var k = (caller, spender);\n  if allowance.contains(k) then (\n    var previous = allowance[k].amount;\n    dofailif(previous > 0 and value > 0, (("UnsafeAllowanceChange", previous)));\n  );\n  allowance.addupdate( k, { amount = value });\n}\n')))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," statement means there is a logical contradiction. In the case above, it is not possible that the object with key ",(0,o.kt)("inlineCode",{parentName:"p"},"(caller,spender)")," does not exist, as it is the semantic of the ",(0,o.kt)("inlineCode",{parentName:"p"},"addupdate")," instruction (see code above in 'entrypoint' tab)."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"otherwise")," statements are presented below for instructions ",(0,o.kt)("inlineCode",{parentName:"p"},"add"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"remove"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"addupdate"),":"),(0,o.kt)(l.Z,{defaultValue:"add",values:[{label:"Add",value:"add"},{label:"Remove",value:"remove"},{label:"Update",value:"update"},{label:"Addupdate",value:"addupdate"}],mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"add",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = c[k] in\n  let some ba = before.c[k] in\n    false (* add fails if key already exists *)\n  otherwise\n    a = <ADDEDOBJECT>\notherwise\n  false (* object should exist after *)\n"))),(0,o.kt)(s.Z,{value:"remove",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = c[k] in\n  false (* object should not exist after *)\notherwise\n  let some ba = before.c[k] in\n    <REMOVED> (* say something about removed object *)\n  otherwise\n    false (* remove fails if key not found *)\n"))),(0,o.kt)(s.Z,{value:"update",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = c[k] in\n  let some ba = before.c[k] in\n    a = { ba with <CHANGES> }\n  otherwise\n    false (* update fails if key not found *)\notherwise\n  false (* update does not remove object *)\n"))),(0,o.kt)(s.Z,{value:"addupdate",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"let some a = c[k] in\n  let some ba = before.c[k] in\n    a = { ba with <CHANGES> }\n  otherwise\n    a = <ADDEDOBJECT>\notherwise\n  false (* update does not remove object *)\n")))),(0,o.kt)("h3",{id:"no-change-1"},"No change"),(0,o.kt)("p",null,"Postconditions say which objects are ",(0,o.kt)("strong",{parentName:"p"},"not")," changed with a statement of the following form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"forall a in c,\n  <NOTCHANGED> ->\n  let some ba = before.c[k] in\n    a = ba\n  otherwise\n    false\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"CHANGED")," is the statement to say that object ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," is not a changed object."),(0,o.kt)("p",null,"When object with key ",(0,o.kt)("inlineCode",{parentName:"p"},"k")," is the only object changed, the postcondition is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"forall a in c,\n  a.<KEY> <> k ->\n  let some ba = before.c[k] in\n    a = ba\n  otherwise\n    false\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"KEY")," is the key field of the asset."),(0,o.kt)("h3",{id:"unknown-ids"},"Unknown ids"),(0,o.kt)("p",null,"When changed objects are not known by their ids, but rather by a business rule based on object data, the goal is to state the effect of the change on the collection."),(0,o.kt)("p",null,"For example, below is the postcondition ",(0,o.kt)("inlineCode",{parentName:"p"},"p2")," for the entrypoint ",(0,o.kt)("inlineCode",{parentName:"p"},"consume")," of the ",(0,o.kt)(r.Z,{to:"/docs/templates/miles",mdxType:"Link"},"Miles")," contract. It states that the entrypoint reduces by parameter value ",(0,o.kt)("inlineCode",{parentName:"p"},"quantity")," the total number of miles, which is the business intent of the entrypoint:"),(0,o.kt)(l.Z,{defaultValue:"specification",values:[{label:"Specification",value:"specification"},{label:"Entrypoint",value:"archetype"}],mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"specification",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"}," mile.sum(the.amount) = before.mile.sum(the.amount) - quantity\n")),(0,o.kt)("p",null,"The total number of miles is obtained by summing the field ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," because miles are stored per bunch associated to an expiration date.")),(0,o.kt)(s.Z,{value:"archetype",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},'entry consume (ow : address, quantity : nat) {\n  called by admin\n  effect {\n    var lview = owner[ow].miles.sort(expiration).select(the.expiration >= now);\n    dorequire (lview.sum(the.amount) >= quantity, "NotEnoughMiles");\n    var remainder = quantity;\n    for : loop m in lview do\n      if remainder > 0 then begin\n        if mile[m].amount > remainder then begin\n          mile.update(m, { amount -= remainder });\n          remainder := 0\n        end else if mile[m].amount = remainder then begin\n          remainder := 0;\n          owner[ow].miles.remove(m)\n        end else begin\n          remainder -= mile[m].amount;\n          owner[ow].miles.remove(m)\n        end\n      end\n    done;\n    assert p1\n  }\n}\n')))),(0,o.kt)("p",null,"Note that in this case, it is more complex to state exactly which miles are changed or not changed, as it is the result of an iteration process over a sorted and filtered set of miles."),(0,o.kt)("p",null,"It is interesting though to make sure that only not expired miles are consumed (removed), since it is another key functional element of the contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"forall m in removed.mile, m.expiration > now\n")),(0,o.kt)("p",null,"Note that Archetype specification language provides convenient handlers for removed or added assets. Another way to phrase this property is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-archetype"},"forall bm in before.mile,\n let some m = mile[bm.id] in\n  false (* no mile is added by the entrypoint *)\n otherwise\n  m.expiration > now\n")))}k.isMDXComponent=!0},6010:function(e,t,n){"use strict";function a(e){var t,n,i="";if("string"==typeof e||"number"==typeof e)i+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(i&&(i+=" "),i+=n);else for(t in e)e[t]&&(i&&(i+=" "),i+=t);return i}function i(){for(var e,t,n=0,i="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(i&&(i+=" "),i+=t);return i}n.d(t,{Z:function(){return i}})}}]);