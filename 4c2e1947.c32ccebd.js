(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{123:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"metadata",(function(){return s})),a.d(t,"toc",(function(){return l})),a.d(t,"default",(function(){return b}));var i=a(3),o=a(7),n=(a(0),a(228)),r=(a(231),a(229)),c={id:"contract4",title:"Formal Verification",sidebar_label:"Formal Verification",slug:"/contract/formal-verification",hide_title:!1},s={unversionedId:"contract/contract4",id:"contract/contract4",isDocsHomePage:!1,title:"Formal Verification",description:"Introduction",source:"@site/docs/contract/contract4.md",slug:"/contract/formal-verification",permalink:"/docs/contract/formal-verification",editUrl:"https://github.com/edukera/completium-landing/tree/master/docs/contract/contract4.md",version:"current",sidebar_label:"Formal Verification",sidebar:"contract",previous:{title:"Test Scenario",permalink:"/docs/contract/test-scenario"}},l=[{value:"Introduction",id:"introduction",children:[]},{value:"Benefit",id:"benefit",children:[]},{value:"Limits",id:"limits",children:[]},{value:"Tools",id:"tools",children:[]}],p={toc:l};function b(e){var t=e.components,a=Object(o.a)(e,["components"]);return Object(n.b)("wrapper",Object(i.a)({},p,a,{components:t,mdxType:"MDXLayout"}),Object(n.b)("h2",{id:"introduction"},"Introduction"),Object(n.b)("p",null,"Formal verification is the act of proving or disproving the correctness of a program with respect to a certain formal specification, using formal methods of mathematics."),Object(n.b)("p",null,"A formal specification uses a formal language to describe what the program is supposed to do. A formal language is defined by a grammar (a set of rules that define how sentences are formed) such that it is possible to decide programmatically whether sentences are correctly formed or not."),Object(n.b)("p",null,"Formal language makes it possible to automatically analyze whether a program has the properties stated by a formal specification, that is whether the program verifies a (formal) specification."),Object(n.b)("p",null,"A fundamental result of computer science is that it is not possible to decide automatically whether any program verifies any specification, that is that there is no single program that can decide whether a program verifies a specification. However, there is a wide range of verification problems (simpler ones) that can be solved automatically."),Object(n.b)("p",null,"When automatic approaches fail, it is then possible to interact with formal method systems to formally solve the problem. The standard verification process is then semi-automatic."),Object(n.b)("h2",{id:"benefit"},"Benefit"),Object(n.b)("p",null,"Consider the following function:"),Object(n.b)("pre",null,Object(n.b)("code",Object(i.a)({parentName:"pre"},{className:"language-archetype"}),"function sum(n : int) =  if n > 0 then  n + sum(n - 1) else 0\n")),Object(n.b)("p",null,"And the formal property ",Object(n.b)("em",{parentName:"p"},"P"),":"),Object(n.b)("pre",null,Object(n.b)("code",Object(i.a)({parentName:"pre"},{className:"language-archetype"}),"forall n, n >=0 => sum(n) = n * (n + 1) / 2\n")),Object(n.b)("p",null,"which reads: for every integer n, if n is above 0, then ",Object(n.b)("inlineCode",{parentName:"p"},"sum(n)")," is equal to n multiplied by n plus 1, devided by 2."),Object(n.b)("p",null,"How to make sure that ",Object(n.b)("inlineCode",{parentName:"p"},"sum")," verifies P?"),Object(n.b)("p",null,"You can either write a test program that computes the ",Object(n.b)("inlineCode",{parentName:"p"},"sum")," function for a wide range of n values, say from 0 to 1000000, and checks the formula; or you can ",Object(n.b)("em",{parentName:"p"},"mathematically")," prove the property (with inductive reasoning for example)."),Object(n.b)("p",null,"With the test approach, you may be reasonably confident in the test program, and by transtion in the ",Object(n.b)("inlineCode",{parentName:"p"},"run")," function; however the property is tested only on a limited set of values, and the test program may itself contain bugs."),Object(n.b)("p",null,"With mathematic reasoning, properties are proven for any parameter value; the confidence is then stronger. It just relies on whether the proof is correct or not."),Object(n.b)("p",null,"Another fundamental result is that it is possible to automatically decide whether any proof is correct or not, as long as it is formalized. Hence the confidence you get with formal methods does not rely on the confidence you may give the developper of the program and tests, but it relies on the ",Object(n.b)("em",{parentName:"p"},"existence")," of a correct formal proof."),Object(n.b)("p",null,"As such, formal verification provides ",Object(n.b)("em",{parentName:"p"},"trust-less")," confidence that a program verifies a formal specfication. That's why it is a key point for the development of smart contracts: with smart contracts, blockchains lose their trust-less execution feature, which they can claim back with formal verification..."),Object(n.b)("h2",{id:"limits"},"Limits"),Object(n.b)("p",null,"Formal verification is relative to the specification. It is possible that a verified program does not behave as expected if this expectation has not been formalized in the specification."),Object(n.b)("p",null,"Another caveat of formal verification is the difficulty to read specification. Which confidence can you have in a verified program if you do not understand the specification?"),Object(n.b)("p",null,"That's why writing specification is a key step of the process."),Object(n.b)("h2",{id:"tools"},"Tools"),Object(n.b)("p",null,"The ",Object(n.b)(r.a,{to:"/docs/dapp-tools/tezos",mdxType:"Link"},"Tezos")," community provides a rich technical and human eco-system regarding formal verification:"),Object(n.b)("table",null,Object(n.b)("thead",{parentName:"table"},Object(n.b)("tr",{parentName:"thead"},Object(n.b)("th",Object(i.a)({parentName:"tr"},{align:null}),"Tools"),Object(n.b)("th",Object(i.a)({parentName:"tr"},{align:"left"}),"Description"))),Object(n.b)("tbody",{parentName:"table"},Object(n.b)("tr",{parentName:"tbody"},Object(n.b)("td",Object(i.a)({parentName:"tr"},{align:null}),Object(n.b)("a",{href:"https://gitlab.com/nomadic-labs/mi-cho-coq/",target:"_blank"},"Michocoq")),Object(n.b)("td",Object(i.a)({parentName:"tr"},{align:"left"}),"A specification of Michelson in ",Object(n.b)("a",{href:"https://coq.inria.fr/",target:"_blank"},"Coq")," to prove properties about smart contracts in Tezos.")),Object(n.b)("tr",{parentName:"tbody"},Object(n.b)("td",Object(i.a)({parentName:"tr"},{align:null}),Object(n.b)("a",{href:"https://archetype-lang.org/"},"Archetype")),Object(n.b)("td",Object(i.a)({parentName:"tr"},{align:"left"}),"Archetype provides a specification language for contract invariant and entry point postconditions. It generates the contract in the ",Object(n.b)("a",{href:"http://why3.lri.fr/",target:"_blank"},"Why3")," language for verification")))))}b.isMDXComponent=!0}}]);